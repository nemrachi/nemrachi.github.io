module Commons.Position exposing (MousePosition, NodePositions, Position, calculatePositions, const_POSITION_ZERO, getNodePosition, preservePositionsUniquely, stringifyXY)

import Commons.Constant exposing (const_XY_OFFSET)
import Commons.Dict exposing (pop)
import Diagrams.Graph exposing (Graph, Node, NodeId)
import Dict exposing (Dict)


type alias Position =
    { x : Float
    , y : Float
    }


type alias MousePosition =
    Position


const_POSITION_ZERO : Position
const_POSITION_ZERO =
    { x = 0, y = 0 }


type alias NodePositions =
    Dict NodeId Position


stringifyXY : Position -> ( String, String )
stringifyXY position =
    ( String.fromFloat position.x, String.fromFloat position.y )


getNodePosition : NodeId -> NodePositions -> Position
getNodePosition nodeId nodePositions =
    Dict.get nodeId nodePositions |> Maybe.withDefault const_POSITION_ZERO


calculatePositions : NodeId -> Position -> Graph -> NodePositions -> NodePositions
calculatePositions parentId position graph visited =
    let
        ( visitedParent, parentPosition ) =
            case Dict.get parentId visited of
                Just pos ->
                    ( visited, pos )

                Nothing ->
                    let
                        uniquePosition =
                            ensureUniquePosition position visited

                        updatedVisited =
                            Dict.insert parentId uniquePosition visited
                    in
                    ( updatedVisited, uniquePosition )

        ( children, remainingDiagram ) =
            pop parentId graph

        visitedChildren =
            case children of
                Just childNodes ->
                    assignChildPositions parentPosition childNodes visitedParent

                Nothing ->
                    visitedParent

        nextParent =
            List.head (Dict.keys remainingDiagram)
    in
    case nextParent of
        Just next ->
            calculatePositions next (Position position.x (position.y + const_XY_OFFSET)) remainingDiagram visitedChildren

        Nothing ->
            visitedChildren


preservePositionsUniquely : NodePositions -> NodePositions -> NodePositions
preservePositionsUniquely oldPositions newPositions =
    let
        merged =
            Dict.merge
                -- if only in oldPositions, skip
                (\_ _ acc -> acc)
                -- if in both, use value from oldPositions
                (\key oldPos _ acc -> Dict.insert key oldPos acc)
                -- if only in newPositions, keep original value from newPositions
                (\key newPos acc -> Dict.insert key newPos acc)
                oldPositions
                newPositions
                Dict.empty
    in
    List.foldl
        (\( nodeId, pos ) acc -> Dict.insert nodeId (ensureUniquePosition pos acc) acc)
        Dict.empty
        (Dict.toList merged)



-- HELPERS


assignChildPositions : Position -> List Node -> NodePositions -> NodePositions
assignChildPositions parentPosition children visited =
    let
        halfCount =
            round (toFloat (List.length children) / 3)

        -- source: generated by ChatGPT
        ( _, ( _, finalPositions ) ) =
            List.foldl
                (\node ( index, ( currentVisited, newPositions ) ) ->
                    let
                        ( updatedVisited, updatedPositions ) =
                            processChild ( index, ( currentVisited, newPositions ) ) halfCount parentPosition node
                    in
                    ( index + 1, ( updatedVisited, updatedPositions ) )
                )
                ( 0, ( visited, Dict.empty ) )
                children
    in
    Dict.union visited finalPositions


processChild : ( Int, ( NodePositions, NodePositions ) ) -> Int -> Position -> Node -> ( NodePositions, NodePositions )
processChild ( index, ( currentVisited, newPositions ) ) halfCount parentPos childNode =
    let
        offset =
            toFloat (index - halfCount)

        candidatePosition =
            calculateNodePosition childNode.name parentPos offset currentVisited

        uniquePosition =
            ensureUniquePosition candidatePosition currentVisited

        updatedVisited =
            Dict.insert childNode.name uniquePosition currentVisited

        updatedPositions =
            Dict.insert childNode.name uniquePosition newPositions
    in
    ( updatedVisited, updatedPositions )


calculateNodePosition : NodeId -> Position -> Float -> NodePositions -> Position
calculateNodePosition nodeId parentPos offset visited =
    case Dict.get nodeId visited of
        Just pos ->
            if parentPos.y >= pos.y then
                { x = offset * const_XY_OFFSET, y = parentPos.y + const_XY_OFFSET }

            else
                pos

        Nothing ->
            { x = offset * const_XY_OFFSET, y = parentPos.y + const_XY_OFFSET }


ensureUniquePosition : Position -> NodePositions -> Position
ensureUniquePosition position positions =
    if Dict.values positions |> List.any (\pos -> pos.x == position.x && pos.y == position.y) then
        ensureUniquePosition { position | x = position.x + const_XY_OFFSET } positions

    else
        position
