module Commons.Graphics exposing (arrowLine, calculateNodeSize, calculateViewBoxSize, draggableCircle, draggableDoubleStrokedCircle, draggableRoundedBoxWithText, noSelectableText, personIconWithText)

import Commons.Constant exposing (const_NODE_BOX_WIDTH, const_TEXT_LINE_HEIGHT, const_VIEWBOX_PADDING)
import Commons.Mouse exposing (onMouseDown)
import Commons.Msg exposing (Msg)
import Commons.Position exposing (NodePositions, Position, const_POSITION_ONE, const_POSITION_ZERO, getNodePosition, stringifyXY)
import Commons.TextParser exposing (sliceTextLines)
import Css.Class exposing (noSelectSvgAttributes)
import Diagrams.Type exposing (Node, NodeId, NodeSize)
import Dict
import Svg exposing (..)
import Svg.Attributes exposing (..)



-- LINE


arrowLine : NodeId -> NodeSize -> NodePositions -> Node -> NodeSize -> List (Svg msg)
arrowLine fromNodeId fromSize positions toNode toSize =
    let
        fromPosition =
            getNodePosition fromNodeId positions

        toPosition =
            Dict.get toNode.name positions |> Maybe.withDefault const_POSITION_ONE

        ( start, end ) =
            calculateArrowPointsForBox fromPosition fromSize toPosition toSize

        ( startX, startY ) =
            stringifyXY start

        ( endX, endY ) =
            stringifyXY end
    in
    [ line
        [ x1 startX
        , y1 startY
        , x2 endX
        , y2 endY
        , stroke "black"
        , strokeWidth "1"
        , markerEnd "url(#arrow)"
        ]
        []
    ]



-- TEXT


noSelectableText : NodeId -> Position -> Svg Msg
noSelectableText nodeId position =
    let
        ( posX, posY ) =
            stringifyXY position
    in
    text_
        ([ x posX, y posY, textAnchor "middle", dy ".3em" ]
            ++ noSelectSvgAttributes
        )
        [ Svg.text nodeId ]



-- CIRCLE


draggableCircle : NodeId -> Position -> Float -> String -> Svg Msg
draggableCircle nodeId position radius color =
    circleWithAttrs position radius color [ onMouseDown nodeId ]


draggableDoubleStrokedCircle : NodeId -> Position -> Float -> String -> String -> Svg Msg
draggableDoubleStrokedCircle nodeId position radius innerColor outerColor =
    Svg.g [ onMouseDown nodeId ]
        [ circleWithAttrs position radius outerColor [ stroke innerColor, strokeWidth "1" ]
        , circleWithAttrs position (radius - 5) innerColor []
        ]


circleWithAttrs : Position -> Float -> String -> List (Attribute Msg) -> Svg Msg
circleWithAttrs position radius color extraAttrs =
    let
        ( posX, posY ) =
            stringifyXY position

        rad =
            String.fromFloat radius
    in
    circle
        ([ cx posX
         , cy posY
         , r rad
         , fill color
         ]
            ++ extraAttrs
        )
        []



-- ROUNDED BOX


draggableRoundedBoxWithText : NodeId -> Position -> Float -> String -> Svg Msg
draggableRoundedBoxWithText nodeId position cornerRadius color =
    let
        ( nodeSize, lines ) =
            calculateNodeSizeWithLines nodeId

        rectPosX =
            position.x - (nodeSize.width / 2)

        rectPosY =
            position.y - (nodeSize.height / 2)

        ( textPosX, textPosY ) =
            stringifyXY (Position position.x (rectPosY + 1.3 * const_TEXT_LINE_HEIGHT))
    in
    g [ onMouseDown nodeId ]
        [ rect
            [ x (String.fromFloat rectPosX)
            , y (String.fromFloat rectPosY)
            , width (String.fromFloat nodeSize.width)
            , height (String.fromFloat nodeSize.height)
            , rx (String.fromFloat cornerRadius)
            , ry (String.fromFloat cornerRadius)
            , fill color
            , stroke "black"
            , strokeWidth "1"
            ]
            []
        , text_
            ([ x textPosX, y textPosY, textAnchor "middle", dy ".3em" ]
                ++ noSelectSvgAttributes
            )
            (List.indexedMap
                (\i line ->
                    -- source: generated by ChatGPT
                    Svg.tspan
                        [ Svg.Attributes.x textPosX
                        , Svg.Attributes.dy
                            (if i == 0 then
                                "0"

                             else
                                String.fromFloat const_TEXT_LINE_HEIGHT
                            )
                        ]
                        [ Svg.text line ]
                )
                lines
            )
        ]



-- PERSON
-- source: generated by ChatGPT


personIconWithText : NodeId -> Position -> Svg Msg
personIconWithText nodeId position =
    let
        headRadius =
            10

        headCenterY =
            position.y - 20

        -- move head above center
        bodyStartY =
            headCenterY + headRadius

        bodyEndY =
            bodyStartY + 20

        armY =
            bodyStartY + 5

        legStartY =
            bodyEndY

        legEndY =
            legStartY + 10

        ( posX, headY ) =
            ( String.fromFloat position.x, String.fromFloat headCenterY )

        ( armLeftX, armRightX ) =
            ( String.fromFloat (position.x - 10), String.fromFloat (position.x + 10) )

        ( legLeftX, legRightX ) =
            ( String.fromFloat (position.x - 10), String.fromFloat (position.x + 10) )
    in
    g [ onMouseDown nodeId ]
        [ circle [ cx posX, cy headY, r "10", fill "black" ] [] -- head
        , line [ x1 posX, y1 (String.fromFloat bodyStartY), x2 posX, y2 (String.fromFloat bodyEndY), stroke "black", strokeWidth "2" ] [] -- body
        , line [ x1 armLeftX, y1 (String.fromFloat armY), x2 armRightX, y2 (String.fromFloat armY), stroke "black", strokeWidth "2" ] [] -- arms
        , line [ x1 posX, y1 (String.fromFloat legStartY), x2 legLeftX, y2 (String.fromFloat legEndY), stroke "black", strokeWidth "2" ] [] -- leg1
        , line [ x1 posX, y1 (String.fromFloat legStartY), x2 legRightX, y2 (String.fromFloat legEndY), stroke "black", strokeWidth "2" ] [] -- leg2
        , noSelectableText nodeId (Position position.x (legEndY + 10))
        ]



-- CALCULATION


calculateViewBoxSize : NodePositions -> String
calculateViewBoxSize positions =
    let
        ( minPos, maxPos ) =
            calculateMinMax positions

        minX =
            minPos.x - const_VIEWBOX_PADDING

        minY =
            minPos.y - const_VIEWBOX_PADDING

        maxX =
            maxPos.x + const_VIEWBOX_PADDING

        maxY =
            maxPos.y + const_VIEWBOX_PADDING
    in
    String.join " "
        [ String.fromFloat minX
        , String.fromFloat minY
        , String.fromFloat (maxX - minX)
        , String.fromFloat (maxY - minY)
        ]


calculateNodeSize : NodeId -> NodeSize
calculateNodeSize nodeId =
    calculateNodeSizeWithLines nodeId |> Tuple.first



-- HELPERS


calculateMinMax : NodePositions -> ( Position, Position )
calculateMinMax positions =
    Dict.values positions
        |> List.foldl
            (\pos ( minPos, maxPos ) ->
                ( { x = Basics.min minPos.x pos.x, y = Basics.min minPos.y pos.y }
                , { x = Basics.max maxPos.x pos.x, y = Basics.max maxPos.y pos.y }
                )
            )
            ( const_POSITION_ZERO, const_POSITION_ZERO )


calculateNodeSizeWithLines : String -> ( NodeSize, List String )
calculateNodeSizeWithLines text =
    let
        boxWidth =
            const_NODE_BOX_WIDTH

        lines =
            sliceTextLines (floor (boxWidth / 9)) text

        boxHeight =
            const_TEXT_LINE_HEIGHT * toFloat (List.length lines) + const_TEXT_LINE_HEIGHT
    in
    ( { width = boxWidth, height = boxHeight }, lines )


calculateArrowPointsForBox : Position -> NodeSize -> Position -> NodeSize -> ( Position, Position )
calculateArrowPointsForBox fromPos fromSize toPos toSize =
    -- source: generated by ChatGPT
    let
        dx =
            toPos.x - fromPos.x

        dy =
            toPos.y - fromPos.y

        angle =
            Basics.atan2 dy dx

        offsetXFrom =
            (fromSize.width / 2) * Basics.cos angle

        offsetYFrom =
            (fromSize.height / 2) * Basics.sin angle

        offsetXTo =
            (toSize.width / 2) * Basics.cos angle

        offsetYTo =
            (toSize.height / 2) * Basics.sin angle
    in
    ( { x = fromPos.x + offsetXFrom, y = fromPos.y + offsetYFrom }
    , { x = toPos.x - offsetXTo, y = toPos.y - offsetYTo }
    )
